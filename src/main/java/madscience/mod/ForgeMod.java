package madscience.mod;


import cpw.mods.fml.common.FMLLog;
import cpw.mods.fml.common.Mod;
import cpw.mods.fml.common.Mod.EventHandler;
import cpw.mods.fml.common.Mod.Instance;
import cpw.mods.fml.common.SidedProxy;
import cpw.mods.fml.common.event.FMLFingerprintViolationEvent;
import cpw.mods.fml.common.event.FMLInitializationEvent;
import cpw.mods.fml.common.event.FMLPostInitializationEvent;
import cpw.mods.fml.common.event.FMLPreInitializationEvent;
import cpw.mods.fml.common.network.NetworkMod;
import cpw.mods.fml.common.network.NetworkRegistry;
import madscience.ModMetadata;
import madscience.factory.FluidFactory;
import madscience.factory.ItemFactory;
import madscience.factory.TileEntityFactory;
import madscience.fluid.UnregisteredFluid;
import madscience.item.SubItemsArchive;
import madscience.item.UnregisteredItem;
import madscience.network.PacketHandler;
import madscience.network.UpdateChecker;
import madscience.product.ItemFactoryProduct;
import madscience.product.TileEntityFactoryProduct;
import madscience.proxy.CommonProxy;
import madscience.recipe.RecipeArchive;
import madscience.tile.UnregisteredMachine;
import net.minecraft.item.ItemStack;
import net.minecraft.launchwrapper.LogWrapper;
import net.minecraftforge.common.Configuration;

import java.util.Arrays;
import java.util.Iterator;


@Mod(modid = ModMetadata.ID,
     name = ModMetadata.NAME,
     version = ModMetadata.VERSION_FULL,
     useMetadata = false,
     acceptedMinecraftVersions = ModMetadata.MINECRAFT_VERSION,
     dependencies = ModMetadata.DEPENDENCIES)
@NetworkMod(channels = {ModMetadata.CHANNEL_NAME},
            packetHandler = PacketHandler.class,
            clientSideRequired = true,
            serverSideRequired = false)
public class ForgeMod
{
    // Proxy that runs commands based on where they are from so we can separate server and client logic easily.
    @SidedProxy(clientSide = ModMetadata.CLIENT_PROXY,
                serverSide = ModMetadata.SERVER_PROXY)
    public static CommonProxy proxy;

    // Public instance of our mod that Forge needs to hook us, based on our internal mod ID.
    @Instance(value = ModMetadata.CHANNEL_NAME)
    public static ForgeMod instance;

    // Public extra data about our mod that Forge uses in the mods listing page for more information.
    @Mod.Metadata(ModMetadata.ID)
    private static cpw.mods.fml.common.ModMetadata metadata;

    // Hooks Forge's replacement openGUI function so we can route our own ID's to proper interfaces.
    private static GUIHandler guiHandler = new GUIHandler();

    @EventHandler
    public void preInit(FMLPreInitializationEvent event) // NO_UCD (unused code)
    {
        // --------------
        // PRE-INIT START
        // --------------

        // Register instance.
        instance = this;

        // Populate generic logger with instance provided by Minecraft/Forge. 
        ModLoader.setLog( event.getModLog(),
                          FMLLog.getLogger() );

        // Determine if we will be able to make use of our special frame buffer to render items and blocks for JSON information dump.
        if (developmentMode())
        {
            proxy.probeOpenGLCapabities();
        }

        // Generate and read our standardized Forge configuration file.
        Configuration config = new Configuration( event.getSuggestedConfigurationFile() );

        // Load existing configuration data.
        config.load();

        // Configure block and item ID's for all unregistered products.
        this.configureTileEntities( config );
        this.configureItems( config );
        this.configureFluids( config );

        // Save any changed or added values to config.
        config.save();

        // Setup Mod Metadata for players to see in mod list with other mods.
        metadata.modId = ModMetadata.ID;
        metadata.name = ModMetadata.NAME;
        metadata.description = ModMetadata.DESCRIPTION;
        metadata.url = ModMetadata.HOME_URL;
        metadata.logoFile = ModMetadata.LOGO_PATH;
        metadata.version = ModMetadata.VMAJOR + "." + ModMetadata.VMINOR +
                           ModMetadata.VREVISION;
        metadata.authorList = Arrays.asList( ModMetadata.AUTHORS );
        metadata.credits = ModMetadata.CREDITS;
        metadata.autogenerated = false;

        // Register all unregistered products with their respective factories.
        this.loadItems();
        this.loadFluids();
        this.loadTileEntities();
    }

    /**
     * Returns true if the loaded mod project is in development mode.
     * This is determined by checking if the mod ID equals 'mineapi'.
     */
    public boolean developmentMode()
    {
        return ModMetadata.ID.equals( "mineapi" );
    }

    @EventHandler
    public void init(FMLInitializationEvent event) // NO_UCD (unused code)
    {
        // -------------
        // INIT - MIDDLE
        // -------------

        // Register special FBO helper and ItemStack renderer if in debugging mode.
        if (developmentMode())
        {
            proxy.tryEnableItemStackRenderer();
        }

        // Registers sound handler which will be called to load sounds added to event bus for sounds.
        proxy.registerSoundHandler();

        // Registers GUI handler which allows server and client to map ID's to GUI's.
        NetworkRegistry.instance().registerGuiHandler( ForgeMod.instance,
                                                       ForgeMod.guiHandler );

        // Check Mad Science Jenkins build server for latest build numbers to compare with running one.
        UpdateChecker.checkJenkinsBuildNumbers();
    }

    @EventHandler
    @SuppressWarnings({
                              "rawtypes",
                              "unchecked"
                      })
    public void postInit(FMLPostInitializationEvent event) // NO_UCD (unused code)
    {
        // --------------
        // POST-INIT LAST
        // --------------

        // Loads all shaped and shapeless (and vanilla furnace) recipes required by factory products.
        this.recipeItems();
        this.recipeTileEntity();

        //        // Interface with NEI and attempt to call functions from it if it exists.
        //        // Note: This method was given by Alex_hawks, buy him a beer if you see him!
        //        if (Loader.isModLoaded("NotEnoughItems"))
        //        {
        //            try
        //            {
        //                Class clazz = Class.forName("codechicken.nei.api.API");
        //                Method m = clazz.getMethod("hideItem", Integer.TYPE);
        //
        //                // Magazine Loader Ghost Block.
        //                //m.invoke(null, MadFurnaces.MAGLOADERGHOST.blockID);
        //            }
        //            catch (Throwable err)
        //            {
        //                ModLoader.log().log(Level.WARNING, "NEI Integration has failed...");
        //                ModLoader.log().log(Level.WARNING, "Please email devs@madsciencemod.com the following stacktrace.");
        //                err.printStackTrace();
        //                ModLoader.log().log(Level.WARNING, "Spamming console to make more obvious...");
        //                for (int i = 0; i < 15; i++)
        //                {
        //                    ModLoader.log().log(Level.WARNING, "Something Broke. See above.");
        //                }
        //            }
        //
        //        }

        // ---------
        // DEBUGGING
        // ---------

        // Check if we are in debugging mode by asking if mod ID equals API name.
        if (developmentMode())
        {
            // Prints out all internal names.
            proxy.dumpGameAssetJSON();

            // Dumps all registered machine, item and fluid JSON to disk.
            //proxy.dumpModProjectJSON();
        }
    }

    private void recipeTileEntity()
    {
        Iterable<TileEntityFactoryProduct> registeredMachines = TileEntityFactory.instance().getMachineInfoList();
        for (Iterator iterator = registeredMachines.iterator(); iterator.hasNext(); )
        {
            TileEntityFactoryProduct registeredMachine = (TileEntityFactoryProduct) iterator.next();
            if (registeredMachine != null)
            {
                // Recipes that pertain to machine itself, association slots with items they should have in them.
                registeredMachine.loadMachineInternalRecipes();

                // Recipes for crafting the machine itself, registered with Minecraft/Forge GameRegistry.
                RecipeArchive.loadCraftingRecipes( registeredMachine.getCraftingRecipe(),
                                                   registeredMachine.getMachineName(),
                                                   new ItemStack( registeredMachine.getBlockContainer() ) );
            }
        }
    }

    private void recipeItems()
    {
        Iterable<ItemFactoryProduct> registeredItems = ItemFactory.instance().getItemInfoList();
        for (Iterator iterator = registeredItems.iterator(); iterator.hasNext(); )
        {
            ItemFactoryProduct registeredItem = (ItemFactoryProduct) iterator.next();
            if (registeredItem != null)
            {
                // Recipes for crafting the item (if one exists, since most are made by machines).
                // Note: ItemStack that is sent will have output amount changed according to recipe.
                for (SubItemsArchive subItem : registeredItem.getSubItems())
                {
                    RecipeArchive.loadCraftingRecipes( subItem.getCraftingRecipes(),
                                                       subItem.getItemName(),
                                                       new ItemStack( registeredItem.getItem(),
                                                                      1,
                                                                      subItem.getMetaID() ) );

                    // Recipes for cooking one item into another in vanilla Minecraft furnace.
                    RecipeArchive.loadVanillaFurnaceRecipes( subItem.getFurnaceRecipes() );
                }
            }
        }
    }

    @EventHandler
    public void invalidFingerprint(FMLFingerprintViolationEvent event) // NO_UCD (unused code)
    {
        // Check to see if fingerprint matches what we expect.
        if (ModMetadata.FINGERPRINT.equals( ModMetadata.FINGERPRINT ))
        {
            LogWrapper.warning( "The copy of " + ModMetadata.NAME +
                                " that you are running passesd all verification and fingerprint checks. It has not been modified from original." );
        }
        else
        {
            LogWrapper.severe( "The copy of " + ModMetadata.NAME +
                               " that you are running has been modified from the original, and unpredictable things may happen. Please consider re-downloading the original version of the mod." );
        }
    }

    private void loadTileEntities()
    {
        ModLoader.log().info( "Creating Tile Entities" );

        // Take the machines from loaded mod instance and register them with tile entity factory.
        UnregisteredMachine[] machineData = ModLoader.getUnregisteredMachines();
        for (int i = 0; i < machineData.length; i++)
        {
            UnregisteredMachine unregisteredMachine = machineData[i];
            TileEntityFactory.instance().registerMachine( unregisteredMachine );
        }
    }

    private void loadItems()
    {
        ModLoader.log().info( "Creating Items" );

        // Grab all unregistered items from mod manager and pass them through the item factory.
        UnregisteredItem[] itemData = ModLoader.getUnregisteredItems();
        for (int i = 0; i < itemData.length; i++)
        {
            UnregisteredItem unregisteredItem = itemData[i];
            ItemFactory.instance().registerItem( unregisteredItem );
        }
    }

    private void loadFluids()
    {
        ModLoader.log().info( "Creating Fluids" );

        // Take the fluids from loaded mod instance and register them with fluid factory.
        UnregisteredFluid[] fluidData = ModLoader.getUnregisteredFluids();
        for (int i = 0; i < fluidData.length; i++)
        {
            UnregisteredFluid unregisteredFluid = fluidData[i];
            FluidFactory.instance().registerFluid( unregisteredFluid );
        }
    }

    private void configureTileEntities(Configuration config)
    {
        UnregisteredMachine[] machineData = ModLoader.getUnregisteredMachines();
        for (int x = 0; x < machineData.length; x++)
        {
            UnregisteredMachine unregisteredMachine = machineData[x];

            // Get a new block ID from our ID manager, and set the block ID for our unregistered machine to whatever ID Manager decides.
            int defaultBlockID = ModLoader.getNextBlockID();
            unregisteredMachine.setBlockID( defaultBlockID );

            // Get configuration file information, if there is any...
            int configBlockID = config.getBlock( Configuration.CATEGORY_BLOCK,
                                                 unregisteredMachine.getMachineName(),
                                                 unregisteredMachine.getBlockID() ).getInt();

            // Check if unregistered machine default ID is different from read value.
            if (unregisteredMachine.getBlockID() == configBlockID)
            {
                ModLoader.log().info( "[" +
                                      unregisteredMachine.getMachineName() +
                                      "]Using default block ID of " +
                                      String.valueOf( configBlockID ) );
            }
            else
            {
                ModLoader.log().info( "[" +
                                      unregisteredMachine.getMachineName() +
                                      "]Using user configured block ID of " +
                                      String.valueOf( configBlockID ) );
            }
        }
    }

    private void configureItems(Configuration config)
    {
        UnregisteredItem[] itemData = ModLoader.getUnregisteredItems();
        for (int i = 0; i < itemData.length; i++)
        {
            UnregisteredItem unregisteredItem = itemData[i];

            // Get new item ID from ID manager, use this as default.
            int defaultItemID = ModLoader.getNextItemID();
            unregisteredItem.setItemID( defaultItemID );

            // Grab existing item item ID configuration if it exists.
            int configItemID = config.getItem( Configuration.CATEGORY_ITEM,
                                               unregisteredItem.getItemBaseName(),
                                               unregisteredItem.getItemID() ).getInt();

            // Check if we used the configuration value or the ID manager one.
            if (unregisteredItem.getItemID() == configItemID)
            {
                ModLoader.log().info( "[" +
                                      unregisteredItem.getItemBaseName() +
                                      "]Using default item ID of " +
                                      String.valueOf( configItemID ) );
            }
            else
            {
                ModLoader.log().info( "[" +
                                      unregisteredItem.getItemBaseName() +
                                      "]Using user configured item ID of " +
                                      String.valueOf( configItemID ) );
            }
        }
    }

    private void configureFluids(Configuration config)
    {
        UnregisteredFluid[] fluidData = ModLoader.getUnregisteredFluids();
        for (int x = 0; x < fluidData.length; x++)
        {
            UnregisteredFluid unregisteredFluid = fluidData[x];

            // Get a new block ID from our ID manager, and set the block ID for our unregistered machine to whatever ID Manager decides.
            int defaultFluidID = ModLoader.getNextBlockID();
            unregisteredFluid.setFluidID( defaultFluidID );

            // Get a new item ID from out ID manager for the fluid container (but only if this fluid has one).
            if (unregisteredFluid.hasFluidContainerItem())
            {
                int defaultFluidContainerID = ModLoader.getNextItemID();
                unregisteredFluid.setFluidContainerID( defaultFluidContainerID );
            }

            // Get configuration file information, if there is any...
            int configFluidID = config.getBlock( Configuration.CATEGORY_BLOCK,
                                                 unregisteredFluid.getFluidName(),
                                                 unregisteredFluid.getFluidID() ).getInt();
            int configFluidContainerID = config.getItem( Configuration.CATEGORY_ITEM,
                                                         unregisteredFluid.getFluidContainerName(),
                                                         unregisteredFluid.getFluidContainerID() ).getInt();

            // Check if unregistered fluid default ID is different from read value.
            if (unregisteredFluid.getFluidID() == configFluidID)
            {
                ModLoader.log().info( "[" +
                                      unregisteredFluid.getFluidName() +
                                      "]Using default block ID of " +
                                      String.valueOf( configFluidID ) );
            }
            else
            {
                ModLoader.log().info( "[" +
                                      unregisteredFluid.getFluidName() +
                                      "]Using user configured block ID of " +
                                      String.valueOf( configFluidID ) );
            }

            // Check if unregistered fluid container item ID is different from default ID manager value.
            if (unregisteredFluid.getFluidContainerID() == configFluidContainerID)
            {
                ModLoader.log().info( "[" +
                                      unregisteredFluid.getFluidContainerName() +
                                      "]Using default item ID of " +
                                      String.valueOf( configFluidContainerID ) );
            }
            else
            {
                ModLoader.log().info( "[" +
                                      unregisteredFluid.getFluidContainerName() +
                                      "]Using user configured item ID of " +
                                      String.valueOf( configFluidContainerID ) );
            }
        }
    }
}
